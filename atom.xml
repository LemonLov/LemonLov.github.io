<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>弱爆了的雪饼</title>
  
  <subtitle>心有猛虎，细嗅蔷薇。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lemonlov.github.io/"/>
  <updated>2019-10-18T13:57:34.598Z</updated>
  <id>http://lemonlov.github.io/</id>
  
  <author>
    <name>Arthur</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>尽可能使字符串相等</title>
    <link href="http://lemonlov.github.io/2019/10/18/get-equal-substrings-within-budget/"/>
    <id>http://lemonlov.github.io/2019/10/18/get-equal-substrings-within-budget/</id>
    <published>2019-10-18T13:42:55.000Z</published>
    <updated>2019-10-18T13:57:34.598Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;给你两个长度相同的字符串，s 和 t。</p><p>&emsp;&emsp;将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p>&emsp;&emsp;用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>&emsp;&emsp;如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。</p><p>&emsp;&emsp;如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p><a id="more"></a><p><strong>示例 1:</strong></p><pre><code>输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, cost = 3输出：3解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, cost = 3输出：1解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, cost = 0输出：1解释：你无法作出任何改动，所以最大长度为 1。</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= s.length, t.length &lt;= 10^5</li><li>0 &lt;= maxCost &lt;= 10^6</li><li>s 和 t 都只含小写英文字母。</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget" target="_blank" rel="noopener">https://leetcode-cn.com/problems/get-equal-substrings-within-budget</a></p><hr><p>&emsp;&emsp;滑动窗口法: 先对每个位置 right 求出转换的开销，用 cost[right] 表示。然后从左向右开始逐步增加窗口长度，累加 cost[right]，并不断更新最大转化长度。当 cost[right] 的累加值 window 超过 maxCost 时，将窗口左端 left 右移，直到再次满足累加值 window 小于等于 maxCost，更新最大转化长度，并继续扩展窗口右端。如此往复，直到右端点遍历完整个 cost 数组。</p><p><strong>python实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equalSubstring</span><span class="params">(self, s: str, t: str, maxCost: int)</span> -&gt; int:</span></span><br><span class="line">        cost = []</span><br><span class="line">        window = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span>  <span class="comment"># the left of sliding window</span></span><br><span class="line">        maxLen = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            cost.append(abs(ord(s[right])-ord(t[right]))) <span class="comment"># compute cost of transfrom</span></span><br><span class="line">            window += cost[right] <span class="comment"># compute sum of the values in window</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> window &gt; maxCost:</span><br><span class="line">                window -= cost[left] <span class="comment"># make sure sum of the values in window less than maxCost</span></span><br><span class="line">                left += <span class="number">1</span> <span class="comment"># slide window</span></span><br><span class="line"></span><br><span class="line">            maxLen = max(maxLen, right-left+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> maxLen</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;给你两个长度相同的字符串，s 和 t。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://lemonlov.github.io/categories/Leetcode/"/>
    
    
      <category term="sliding window" scheme="http://lemonlov.github.io/tags/sliding-window/"/>
    
      <category term="python" scheme="http://lemonlov.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使数组严格递增</title>
    <link href="http://lemonlov.github.io/2019/10/11/make-array-strictly-increasing/"/>
    <id>http://lemonlov.github.io/2019/10/11/make-array-strictly-increasing/</id>
    <published>2019-10-11T09:50:16.000Z</published>
    <updated>2019-10-11T10:28:23.414Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。</p><p>&emsp;&emsp;每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 &lt;= i &lt; arr1.length 和 0 &lt;= j &lt; arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。</p><p>&emsp;&emsp;如果无法让 arr1 严格递增，请返回 -1。</p><a id="more"></a><p><strong>示例 1:</strong></p><pre><code>输入：arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]输出：1解释：用 2 来替换 5，之后 arr1 = [1, 2, 3, 6, 7]。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入：arr1 = [1,5,3,6,7], arr2 = [4,3,1]输出：2解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = [1, 3, 4, 6, 7]。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入：arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]输出：-1解释：无法使 arr1 严格递增。</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= arr1.length, arr2.length &lt;= 2000</li><li>0 &lt;= arr1[i], arr2[i] &lt;= 10^9</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/make-array-strictly-increasing" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-array-strictly-increasing</a></p><hr><ol><li>dp[i][j] 表示，将数组arr1的前j个元素通过i次替换后变为严格递增序列时，序列中最后一个元素的值，也是当前严格递增序列中的最大值;</li><li>求 dp[i][j+1] 时，递推如下：如果 arr[j+1] &gt; dp[i][j] ，即 arr[j+1] 大于严格递增序列的最大值时，将 arr[j+1] 直接加在严格递增序列的末尾，即赋值给 dp[i][j+1] ，那么这时的序列应该也是严格递增的，并且此时序列进行替换的次数仍然为i次；</li><li>另外一种选择是将 arr[j+1] 进行元素替换，此时，我们应当在数组arr2中找到第一个比 dp[i-1][j] 大的数，dp[i-1][j] 即前j个元素进行i-1替换后的序列的最大值，我们使用二分查找即可在O(logn)时间复杂度内找到该值，此时我们仍然保证前j+1个元素变为严格递增序列只进行了i次替换；</li><li>递推公式如下:<img src="/2019/10/11/make-array-strictly-increasing/formula.png" alt="递推公式" title="formla"></li><li>我们只需要找到最小转换次数的i，使得满足前n个元素成为严格递增序列即可；</li></ol><p><strong>C++实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeArrayIncreasing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr1.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,INT_MAX));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        sort(arr2.begin(), arr2.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr1[j<span class="number">-1</span>] &gt; dp[i][j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = arr1[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> it = upper_bound(arr2.begin(), arr2.end(), dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                    <span class="keyword">if</span> (it != arr2.end())</span><br><span class="line">                        dp[i][j] = min(dp[i][j], *it);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( j == n &amp;&amp; dp[i][j] != INT_MAX)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><strong>Python实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeArrayIncreasing</span><span class="params">(self, arr1: List[int], arr2: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(arr1)</span><br><span class="line">        maxV = <span class="number">1000000001</span></span><br><span class="line">        dp = [[maxV <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">        arr2.sort()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> arr1[j<span class="number">-1</span>] &gt; dp[i][j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = arr1[j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    loc = bisect.bisect_right(arr2, dp[i<span class="number">-1</span>][j<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">if</span> loc &lt; len(arr2):</span><br><span class="line">                        dp[i][j] = min(dp[i][j], arr2[loc])</span><br><span class="line">                <span class="keyword">if</span> j == n <span class="keyword">and</span> dp[i][j] != maxV:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 &amp;lt;= i &amp;lt; arr1.length 和 0 &amp;lt;= j &amp;lt; arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果无法让 arr1 严格递增，请返回 -1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://lemonlov.github.io/categories/Leetcode/"/>
    
    
      <category term="python" scheme="http://lemonlov.github.io/tags/python/"/>
    
      <category term="动态规划" scheme="http://lemonlov.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="C++" scheme="http://lemonlov.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>黄金矿工</title>
    <link href="http://lemonlov.github.io/2019/10/09/path-with-maximum-gold/"/>
    <id>http://lemonlov.github.io/2019/10/09/path-with-maximum-gold/</id>
    <published>2019-10-09T13:34:32.000Z</published>
    <updated>2019-10-11T10:31:57.755Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。</p><p>&emsp;&emsp;为了使收益最大化，矿工需要按以下规则来开采黄金：</p><ul><li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。</li><li>矿工每次可以从当前位置向上下左右四个方向走。</li><li>每个单元格只能被开采（进入）一次。</li><li>不得开采（进入）黄金数目为 0 的单元格。</li><li>矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。<a id="more"></a></li></ul><p><strong>示例 1:</strong></p><pre><code>输入：grid = [[0,6,0],[5,8,7],[0,9,0]]输出：24解释：[[0,6,0],[5,8,7],[0,9,0]]一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。</code></pre><p><strong>示例 1:</strong></p><pre><code>输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]输出：28解释：[[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= grid.length, grid[i].length &lt;= 15</li><li>0 &lt;= grid[i][j] &lt;= 100</li><li>最多 25 个单元格中有黄金。</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-with-maximum-gold" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-with-maximum-gold</a></p><hr><p>&emsp;&emsp;典型的深度优先搜索（DFS）问题，对于m*n的金矿资源网格上的每一个位置点，都运行一次DFS算法以求出从这一点出发可以获得的最大收益（如果该位置点金矿资源为0，则可不必进行求解），最后从上述最大收益中求出最大值，即为可以收集到的最多黄金。</p><p><strong>C++实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pos[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_income = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= grid.size() || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].size() || !grid[x][y])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = grid[x][y];</span><br><span class="line">            grid[x][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                max_income = max(max_income, dfs(grid, x + pos[i][<span class="number">0</span>], y + pos[i][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            grid[x][y] = temp;</span><br><span class="line">            <span class="keyword">return</span> temp + max_income;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MaxmumGold = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j])</span><br><span class="line">                    MaxmumGold = max(MaxmumGold, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MaxmumGold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;接下来是用python实现的代码，因为问题中金矿资源网格中最多25个单元格中有黄金，这说明这是一个稀疏矩阵，因此用python中基本数据类型中的字典进行存储是很方便的，用代表网格位置的元组用作字典的键，网格里面的金矿数值用作字典的值，极大地方便了金矿位置点的查找。</p><p><strong>Python实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaximumGold</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        dic = &#123;(i,j):grid[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> range(m) <span class="keyword">for</span> j <span class="keyword">in</span> range(n) <span class="keyword">if</span> grid[i][j]&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(pos)</span>:</span></span><br><span class="line">            max_gold = <span class="number">0</span></span><br><span class="line">            posv = dic.pop(pos)</span><br><span class="line">            <span class="keyword">for</span> tpos <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>)]:</span><br><span class="line">                tpos = (pos[<span class="number">0</span>] + tpos[<span class="number">0</span>], pos[<span class="number">1</span>] + tpos[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> tpos <span class="keyword">in</span> dic:</span><br><span class="line">                    max_gold = max(max_gold, dfs(tpos))</span><br><span class="line">            dic[pos] = posv</span><br><span class="line">            <span class="keyword">return</span> posv + max_gold</span><br><span class="line">        <span class="keyword">return</span> max(dfs(item) <span class="keyword">for</span> item <span class="keyword">in</span> list(dic.keys()))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;为了使收益最大化，矿工需要按以下规则来开采黄金：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每当矿工进入一个单元，就会收集该单元格中的所有黄金。&lt;/li&gt;
&lt;li&gt;矿工每次可以从当前位置向上下左右四个方向走。&lt;/li&gt;
&lt;li&gt;每个单元格只能被开采（进入）一次。&lt;/li&gt;
&lt;li&gt;不得开采（进入）黄金数目为 0 的单元格。&lt;/li&gt;
&lt;li&gt;矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://lemonlov.github.io/categories/Leetcode/"/>
    
    
      <category term="python" scheme="http://lemonlov.github.io/tags/python/"/>
    
      <category term="C++" scheme="http://lemonlov.github.io/tags/C/"/>
    
      <category term="DFS" scheme="http://lemonlov.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>机器人冒险</title>
    <link href="http://lemonlov.github.io/2019/09/27/programmable-robot/"/>
    <id>http://lemonlov.github.io/2019/09/27/programmable-robot/</id>
    <published>2019-09-27T12:54:24.000Z</published>
    <updated>2019-09-28T02:33:43.159Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：</p><p>&emsp;&emsp;<em>U: 向y轴正方向移动一格</em><br>&emsp;&emsp;<em>R: 向x轴正方向移动一格。</em></p><p>&emsp;&emsp;不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。</p><p>&emsp;&emsp;给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。</p><a id="more"></a><p><strong>示例 1:</strong></p><pre><code>输入：command = &quot;URR&quot;, obstacles = [], x = 3, y = 2输出：true解释：U(0, 1) -&gt; R(1, 1) -&gt; R(2, 1) -&gt; U(2, 2) -&gt; R(3, 2)。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入：command = &quot;URR&quot;, obstacles = [[2, 2]], x = 3, y = 2输出：false解释：机器人在到达终点前会碰到(2, 2)的障碍物。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入：command = &quot;URR&quot;, obstacles = [[4, 2]], x = 3, y = 2输出：true解释：到达终点后，再碰到障碍物也不影响返回结果。</code></pre><p><strong>限制：</strong></p><pre><code>1. 2 &lt;= command的长度 &lt;= 10002. command由U，R构成，且至少有一个U，至少有一个R3. 0 &lt;= x &lt;= 1e9, 0 &lt;= y &lt;= 1e94. 0 &lt;= obstacles的长度 &lt;= 10005. obstacles[i]不为原点或者终点</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/programmable-robot" target="_blank" rel="noopener">https://leetcode-cn.com/problems/programmable-robot</a></p><hr><p>&emsp;&emsp;这道题目一开始我的思路是模拟机器人的行走过程，然后在机器人每走一步之后判断其是否在障碍点，是否抵达了终点…但我想这样可能会超出时间限制，但我还是想写出来试试，果不其然，<strong>超出时间限制！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robot</span><span class="params">(self, command: str, obstacles: List[List[int]], x: int, y: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> y == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        x0 = y0 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> command:</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">'U'</span>:</span><br><span class="line">                    y0 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x0 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> obs <span class="keyword">in</span> obstacles:</span><br><span class="line">                    <span class="comment"># 障碍点在位置点范围之外</span></span><br><span class="line">                    <span class="keyword">if</span> obs[<span class="number">0</span>] &gt; x0 <span class="keyword">or</span> obs[<span class="number">1</span>] &gt; y0:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> obs == [x0, y0]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 抵达终点</span></span><br><span class="line">                <span class="keyword">if</span> x0 == x <span class="keyword">and</span> y0 == y:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;之后我想着机器人行走路径中的点必然有一种规律，这样题目才可能得以简化，我一开始是想把终点和所有障碍点通过某种方式使之等价于单次循环中机器人可能经过的点，我觉得方向是没错的，但在编程的时候又把问题复杂化了，所以一直没调试出来。<br>&emsp;&emsp;然后看了题解中大佬们的解答，总结出两种方法。一是我们可以根据command推算出机器人的行走路径，比如command=’URR’,我们可以推算出如下坐标：<br>(0,1), (1,1), (2,1)<br>(2,2), (3,2), (4,2)<br>(4,3), (5,3), (6,3)…以此类推<br>从上面我们发现<br>(3,2) - (1,1) = (2,1);<br>(4,3) - (0,1) = (4,2);<br>(6,3) - (2,1) = (4,2);<br>&emsp;&emsp;上面式子的结果都是完整执行一次command命令之后坐标点的倍数。因此判断某个点p是否在行走路径上的条件是：<br>(pos[0] == p[0] and pos[1] == p[1]) or (pos[1] != p[0] and (p[0]-pos[0])/(p[1]-pos[1]) == divpos[0]/divpos[1])<br>&emsp;&emsp;其中pos是单次循环机器人所走过的坐标中的一点，divpos是完整执行一次command命令之后的坐标点。<br>&emsp;&emsp;而机器人能完好到达终点的条件是：(1)终点坐标在行动轨迹上；(2)在到达终点之前没有障碍点在行动轨迹上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robot</span><span class="params">(self, command: str, obstacles: List[List[int]], x: int, y: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> y == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        ori, oripos = [<span class="number">0</span>, <span class="number">0</span>], []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> command:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">'R'</span>:</span><br><span class="line">                ori[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ori[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            oripos.append(ori[:])</span><br><span class="line">        divpos = oripos[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 判断终点是否在行走路径上</span></span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> oripos:</span><br><span class="line">            <span class="keyword">if</span> (pos[<span class="number">0</span>] == x <span class="keyword">and</span> pos[<span class="number">1</span>] == y) <span class="keyword">or</span> (pos[<span class="number">1</span>] != y <span class="keyword">and</span> (x-pos[<span class="number">0</span>])/(y-pos[<span class="number">1</span>]) == divpos[<span class="number">0</span>]/divpos[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 判断障碍物是否在行走路径上</span></span><br><span class="line">        <span class="keyword">for</span> obs <span class="keyword">in</span> obstacles:</span><br><span class="line">            <span class="comment"># 障碍物超出终点</span></span><br><span class="line">            <span class="keyword">if</span> obs[<span class="number">0</span>] &gt; x <span class="keyword">or</span> obs[<span class="number">1</span>] &gt; y:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> pos <span class="keyword">in</span> oripos: <span class="comment"># 判断某个障碍物是否在行走路径上</span></span><br><span class="line">                <span class="keyword">if</span> (pos[<span class="number">0</span>] == obs[<span class="number">0</span>] <span class="keyword">and</span> pos[<span class="number">1</span>] == obs[<span class="number">1</span>]) <span class="keyword">or</span> (pos[<span class="number">1</span>] != obs[<span class="number">1</span>] <span class="keyword">and</span> (obs[<span class="number">0</span>]-pos[<span class="number">0</span>])/(obs[<span class="number">1</span>]-pos[<span class="number">1</span>]) == divpos[<span class="number">0</span>]/divpos[<span class="number">1</span>]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;第二种解法是我们可以通过上面所讲的规律找到接近终点和障碍点的某个点，以这个点为起始我们可以在单次循环中判断终点和障碍点是否在行走路径上。比如对于command=’URR’，在如下坐标点中：<br>(0,1),(1,1),(2,1)<br>(2,2),(3,2),(4,2)<br>(4,3),(5,3),(6,3)<br>&emsp;&emsp;(2,1)是接近(2,2),(3,2),(4,2)三个点的坐标，(4,2)是接近(4,3),(5,3),(6,3)三个点的坐标，也就是(2,1),(4,2)都是(2,1)的倍数，具体求解方法请看代码中get_floor_xy()函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.unit_x = <span class="number">0</span></span><br><span class="line">        self.unit_y = <span class="number">0</span></span><br><span class="line">    <span class="comment"># command指令单循环一次</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_unit</span><span class="params">(self, command)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> command:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">'R'</span>:</span><br><span class="line">                self.unit_x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.unit_y += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 获得在行走路径中最接近[x, y]的路径点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_floor_xy</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="comment"># command至少有一个U和R，所以不必担心除数为0</span></span><br><span class="line">        min_rate = min(x // self.unit_x, y // self.unit_y)</span><br><span class="line">        <span class="keyword">return</span> min_rate * self.unit_x, min_rate * self.unit_y</span><br><span class="line">    <span class="comment"># 判断某个点是否在行走路径上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_the_way</span><span class="params">(self, command, x1, y1)</span>:</span></span><br><span class="line">        x0, y0 = self.get_floor_xy(x1, y1)</span><br><span class="line">        <span class="keyword">if</span> x0 == x1 <span class="keyword">and</span> y0 == y1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 判断单次循环下，是否途径目标点</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> command:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">'R'</span>:</span><br><span class="line">                x0 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y0 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> x0 == x1 <span class="keyword">and</span> y0 == y1:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robot</span><span class="params">(self, command: str, obstacles: List[List[int]], x: int, y: int)</span> -&gt; bool:</span></span><br><span class="line">        self.init_unit(command)</span><br><span class="line">        <span class="comment"># 判断终点是否在行走路径上</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.on_the_way(command, x, y):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 判断障碍点是否在行走路径上</span></span><br><span class="line">        <span class="keyword">for</span> obs <span class="keyword">in</span> obstacles:</span><br><span class="line">            <span class="comment"># 障碍点是否超出了范围</span></span><br><span class="line">            <span class="keyword">if</span> obs[<span class="number">0</span>] &gt; x <span class="keyword">or</span> obs[<span class="number">1</span>] &gt; y:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 障碍点是否在路径上</span></span><br><span class="line">            <span class="keyword">if</span> self.on_the_way(command, obs[<span class="number">0</span>], obs[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;U: 向y轴正方向移动一格&lt;/em&gt;&lt;br&gt;&amp;emsp;&amp;emsp;&lt;em&gt;R: 向x轴正方向移动一格。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://lemonlov.github.io/categories/Leetcode/"/>
    
    
      <category term="python" scheme="http://lemonlov.github.io/tags/python/"/>
    
  </entry>
  
</feed>

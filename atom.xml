<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>弱爆了的雪饼</title>
  
  <subtitle>心有猛虎，细嗅蔷薇。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-28T02:33:43.159Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Arthur</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器人冒险</title>
    <link href="http://yoursite.com/2019/09/27/programmable-robot/"/>
    <id>http://yoursite.com/2019/09/27/programmable-robot/</id>
    <published>2019-09-27T12:54:24.000Z</published>
    <updated>2019-09-28T02:33:43.159Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：</p><p>&emsp;&emsp;<em>U: 向y轴正方向移动一格</em><br>&emsp;&emsp;<em>R: 向x轴正方向移动一格。</em></p><p>&emsp;&emsp;不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。</p><p>&emsp;&emsp;给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。</p><a id="more"></a><p><strong>示例 1:</strong></p><pre><code>输入：command = &quot;URR&quot;, obstacles = [], x = 3, y = 2输出：true解释：U(0, 1) -&gt; R(1, 1) -&gt; R(2, 1) -&gt; U(2, 2) -&gt; R(3, 2)。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入：command = &quot;URR&quot;, obstacles = [[2, 2]], x = 3, y = 2输出：false解释：机器人在到达终点前会碰到(2, 2)的障碍物。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入：command = &quot;URR&quot;, obstacles = [[4, 2]], x = 3, y = 2输出：true解释：到达终点后，再碰到障碍物也不影响返回结果。</code></pre><p><strong>限制：</strong></p><pre><code>1. 2 &lt;= command的长度 &lt;= 10002. command由U，R构成，且至少有一个U，至少有一个R3. 0 &lt;= x &lt;= 1e9, 0 &lt;= y &lt;= 1e94. 0 &lt;= obstacles的长度 &lt;= 10005. obstacles[i]不为原点或者终点</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/programmable-robot" target="_blank" rel="noopener">https://leetcode-cn.com/problems/programmable-robot</a></p><hr><p>&emsp;&emsp;这道题目一开始我的思路是模拟机器人的行走过程，然后在机器人每走一步之后判断其是否在障碍点，是否抵达了终点…但我想这样可能会超出时间限制，但我还是想写出来试试，果不其然，<strong>超出时间限制！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robot</span><span class="params">(self, command: str, obstacles: List[List[int]], x: int, y: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> y == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        x0 = y0 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> command:</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">'U'</span>:</span><br><span class="line">                    y0 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x0 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> obs <span class="keyword">in</span> obstacles:</span><br><span class="line">                    <span class="comment"># 障碍点在位置点范围之外</span></span><br><span class="line">                    <span class="keyword">if</span> obs[<span class="number">0</span>] &gt; x0 <span class="keyword">or</span> obs[<span class="number">1</span>] &gt; y0:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> obs == [x0, y0]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 抵达终点</span></span><br><span class="line">                <span class="keyword">if</span> x0 == x <span class="keyword">and</span> y0 == y:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;之后我想着机器人行走路径中的点必然有一种规律，这样题目才可能得以简化，我一开始是想把终点和所有障碍点通过某种方式使之等价于单次循环中机器人可能经过的点，我觉得方向是没错的，但在编程的时候又把问题复杂化了，所以一直没调试出来。<br>&emsp;&emsp;然后看了题解中大佬们的解答，总结出两种方法。一是我们可以根据command推算出机器人的行走路径，比如command=’URR’,我们可以推算出如下坐标：<br>(0,1), (1,1), (2,1)<br>(2,2), (3,2), (4,2)<br>(4,3), (5,3), (6,3)…以此类推<br>从上面我们发现<br>(3,2) - (1,1) = (2,1);<br>(4,3) - (0,1) = (4,2);<br>(6,3) - (2,1) = (4,2);<br>&emsp;&emsp;上面式子的结果都是完整执行一次command命令之后坐标点的倍数。因此判断某个点p是否在行走路径上的条件是：<br>(pos[0] == p[0] and pos[1] == p[1]) or (pos[1] != p[0] and (p[0]-pos[0])/(p[1]-pos[1]) == divpos[0]/divpos[1])<br>&emsp;&emsp;其中pos是单次循环机器人所走过的坐标中的一点，divpos是完整执行一次command命令之后的坐标点。<br>&emsp;&emsp;而机器人能完好到达终点的条件是：(1)终点坐标在行动轨迹上；(2)在到达终点之前没有障碍点在行动轨迹上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robot</span><span class="params">(self, command: str, obstacles: List[List[int]], x: int, y: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> y == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        ori, oripos = [<span class="number">0</span>, <span class="number">0</span>], []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> command:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">'R'</span>:</span><br><span class="line">                ori[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ori[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            oripos.append(ori[:])</span><br><span class="line">        divpos = oripos[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 判断终点是否在行走路径上</span></span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> oripos:</span><br><span class="line">            <span class="keyword">if</span> (pos[<span class="number">0</span>] == x <span class="keyword">and</span> pos[<span class="number">1</span>] == y) <span class="keyword">or</span> (pos[<span class="number">1</span>] != y <span class="keyword">and</span> (x-pos[<span class="number">0</span>])/(y-pos[<span class="number">1</span>]) == divpos[<span class="number">0</span>]/divpos[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 判断障碍物是否在行走路径上</span></span><br><span class="line">        <span class="keyword">for</span> obs <span class="keyword">in</span> obstacles:</span><br><span class="line">            <span class="comment"># 障碍物超出终点</span></span><br><span class="line">            <span class="keyword">if</span> obs[<span class="number">0</span>] &gt; x <span class="keyword">or</span> obs[<span class="number">1</span>] &gt; y:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> pos <span class="keyword">in</span> oripos: <span class="comment"># 判断某个障碍物是否在行走路径上</span></span><br><span class="line">                <span class="keyword">if</span> (pos[<span class="number">0</span>] == obs[<span class="number">0</span>] <span class="keyword">and</span> pos[<span class="number">1</span>] == obs[<span class="number">1</span>]) <span class="keyword">or</span> (pos[<span class="number">1</span>] != obs[<span class="number">1</span>] <span class="keyword">and</span> (obs[<span class="number">0</span>]-pos[<span class="number">0</span>])/(obs[<span class="number">1</span>]-pos[<span class="number">1</span>]) == divpos[<span class="number">0</span>]/divpos[<span class="number">1</span>]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;第二种解法是我们可以通过上面所讲的规律找到接近终点和障碍点的某个点，以这个点为起始我们可以在单次循环中判断终点和障碍点是否在行走路径上。比如对于command=’URR’，在如下坐标点中：<br>(0,1),(1,1),(2,1)<br>(2,2),(3,2),(4,2)<br>(4,3),(5,3),(6,3)<br>&emsp;&emsp;(2,1)是接近(2,2),(3,2),(4,2)三个点的坐标，(4,2)是接近(4,3),(5,3),(6,3)三个点的坐标，也就是(2,1),(4,2)都是(2,1)的倍数，具体求解方法请看代码中get_floor_xy()函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.unit_x = <span class="number">0</span></span><br><span class="line">        self.unit_y = <span class="number">0</span></span><br><span class="line">    <span class="comment"># command指令单循环一次</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_unit</span><span class="params">(self, command)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> command:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">'R'</span>:</span><br><span class="line">                self.unit_x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.unit_y += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 获得在行走路径中最接近[x, y]的路径点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_floor_xy</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="comment"># command至少有一个U和R，所以不必担心除数为0</span></span><br><span class="line">        min_rate = min(x // self.unit_x, y // self.unit_y)</span><br><span class="line">        <span class="keyword">return</span> min_rate * self.unit_x, min_rate * self.unit_y</span><br><span class="line">    <span class="comment"># 判断某个点是否在行走路径上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_the_way</span><span class="params">(self, command, x1, y1)</span>:</span></span><br><span class="line">        x0, y0 = self.get_floor_xy(x1, y1)</span><br><span class="line">        <span class="keyword">if</span> x0 == x1 <span class="keyword">and</span> y0 == y1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 判断单次循环下，是否途径目标点</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> command:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">'R'</span>:</span><br><span class="line">                x0 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y0 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> x0 == x1 <span class="keyword">and</span> y0 == y1:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robot</span><span class="params">(self, command: str, obstacles: List[List[int]], x: int, y: int)</span> -&gt; bool:</span></span><br><span class="line">        self.init_unit(command)</span><br><span class="line">        <span class="comment"># 判断终点是否在行走路径上</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.on_the_way(command, x, y):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 判断障碍点是否在行走路径上</span></span><br><span class="line">        <span class="keyword">for</span> obs <span class="keyword">in</span> obstacles:</span><br><span class="line">            <span class="comment"># 障碍点是否超出了范围</span></span><br><span class="line">            <span class="keyword">if</span> obs[<span class="number">0</span>] &gt; x <span class="keyword">or</span> obs[<span class="number">1</span>] &gt; y:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 障碍点是否在路径上</span></span><br><span class="line">            <span class="keyword">if</span> self.on_the_way(command, obs[<span class="number">0</span>], obs[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;U: 向y轴正方向移动一格&lt;/em&gt;&lt;br&gt;&amp;emsp;&amp;emsp;&lt;em&gt;R: 向x轴正方向移动一格。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
